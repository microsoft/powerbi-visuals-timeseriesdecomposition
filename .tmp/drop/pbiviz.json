{"visual":{"name":"Time series decomposition","displayName":"Time series decomposition","guid":"PBI_CV_CAD60C71_FAD5_4B59_A498_A7FB0DDC7A2B","visualClassName":"Visual","version":"1.0.1","description":"<span>Time series decomposition is an essential analytics tool to understand time series components and to improve a forecast. The current visual implements the well-known “Seasonal and Trend decomposition using Loess” approach, and provides several types of plots. You can control the algorithm parameters and the visual attributes to suit your needs. <br/><br/><span style='font-style:italic'>Service prerequisites:</span> R-powered custom visual is used in service seamlessly<br/><br /><span style='font-style:italic'>Desktop prerequisites:</span> To run R scripts in Power BI Desktop, you must separately install R on your local computer.<br />You can download and install R for free from the <a href='https://mran.revolutionanalytics.com/download/'>Revolution Open download page</a> or the <a href='https://cran.r-project.org/bin/windows/base/'>CRAN Repository</a><br /><br /> <span style='font-style:italic'> R package dependencies(auto-installed): </span> proto, zoo <br /><br /> <span style='font-style:italic'> Supports R versions: </span> R 3.3.2, R 3.3.1, R 3.3.0, MRO 3.3.1, MRO 3.3.0  <br /></span>","supportUrl":"http://community.powerbi.com/","gitHubUrl":"https://github.com/Microsoft/powerbi-visuals-timeseriesdecomposition"},"apiVersion":"1.3.0","author":{"name":"Microsoft","email":"pbicvsupport@microsoft.com"},"assets":{"icon":"assets/icon.png"},"externalJS":[],"style":"style/visual.less","capabilities":{"dataRoles":[{"displayName":"Time","description":"Time column","kind":"Grouping","name":"Time"},{"displayName":"Value","description":"Numeric column","kind":"Measure","name":"Value"}],"dataViewMappings":[{"conditions":[{"Time":{"max":1},"Value":{"max":1}}],"scriptResult":{"dataInput":{"table":{"rows":{"select":[{"for":{"in":"Time"}},{"for":{"in":"Value"}}],"dataReductionAlgorithm":{"top":{}}}}},"script":{"scriptProviderDefault":"R","scriptOutputType":"png","source":{"objectName":"rcv_script","propertyName":"source"},"provider":{"objectName":"rcv_script","propertyName":"provider"},"scriptSourceDefault":"\r\n###############Library Declarations###############\r\n\r\nlibraryRequireInstall = function(packageName, ...)\r\n{\r\n  if(!require(packageName, character.only = TRUE)) \r\n    warning(paste(\"*** The package: '\", packageName, \"' was not installed ***\",sep=\"\"))\r\n}\r\n\r\nlibraryRequireInstall(\"zoo\")\r\nlibraryRequireInstall(\"proto\")\r\n\r\n################Inner parameters #################################\r\n\r\nSys.setlocale(\"LC_ALL\",\"English\")# internationalization\r\n\r\n# minimum samples for analysis\r\nminSamples2run = 9 \r\n\r\n# minimum unique values\r\nminUniqueValues = 3 \r\n\r\n\r\n################Inner functions #################################\r\n# tiny function to deal with verl long strings on plot\r\ncutStr2Show = function(strText, strCex = 0.8, abbrTo = 100, isH = TRUE, maxChar = 3, partAvailable = 1)\r\n{\r\n  # partAvailable, wich portion of window is available, in [0,1]\r\n  if(is.null(strText))\r\n    return (NULL)\r\n  \r\n  SCL = 0.075 * strCex / 0.8\r\n  pardin = par()$din\r\n  gStand = partAvailable * (isH * pardin[1] + (1 - isH) * pardin[2]) /SCL\r\n  \r\n  # if very very long abbreviate\r\n  if(nchar(strText)>abbrTo && nchar(strText)> 1)\r\n    strText = abbreviate(strText, abbrTo)\r\n  \r\n  # if looooooong convert to lo...\r\n  if(nchar(strText)>round(gStand) && nchar(strText)> 1)\r\n    strText = paste(substring(strText, 1, floor(gStand)), \"...\", sep = \"\")\r\n  \r\n  # if shorter than maxChar remove \r\n  if(gStand <= maxChar)\r\n    strText = NULL\r\n  \r\n  return(strText) \r\n}\r\n\r\n#Info string to be plotted under the chart\r\nCreateInfo = function(modelType, freqv, evars, plotType)\r\n{\r\n  #all, clean, trend, seasonal, remainder, byseason\r\n  pbiInfo =\"\"\r\n  if(plotType == 'all')\r\n    pbiInfo = paste(paste(names(evars), \": \", evars,\"%\",sep=\"\"), collapse = \", \")\r\n  else\r\n    if(plotType %in% c('clean', 'byseasonClean'))\r\n      pbiInfo = paste(paste('clean', \": \", 100-evars[3],\"%\",sep=\"\"), collapse = \", \")\r\n    else\r\n      if(plotType %in% c('trend', 'seasonal', 'remainder'))\r\n        pbiInfo = paste(paste(names(evars[plotType]), \":\", evars[plotType],\"%\",sep=\"\"), collapse = \", \")\r\n      else\r\n        if(plotType == 'byseason')\r\n          pbiInfo = paste(paste(names(evars), \":\", evars,\"%\",sep=\"\"), collapse = \", \")\r\n        \r\n        sN=\"\"\r\n        if(!is.null(names(freqv)[1]) && !is.na(names(freqv)[1]))\r\n          sN = paste(\" / \", names(freqv)[1], sep=\"\")\r\n        \r\n        pbiInfo = paste(\"Model: \", modelType, \", freq = \", as.character(freqv),sN, \", \", pbiInfo, sep =\"\")\r\n        print(pbiInfo)\r\n        return(pbiInfo)\r\n}\r\n\r\n# log on numeric array \r\nmakeLog = function (val)\r\n{\r\n  add = 1 + max(0,min(val)) - min(val)  # heuristic\r\n  transVal = val + add # shift to positive range (>1)\r\n  logVal = log(transVal, base = exp(1))\r\n  mul = norm(val, type = \"2\")/ norm(logVal, type = \"2\")\r\n  logVal =logVal*mul \r\n  return(list(add = add, mul = mul, logVal = logVal, base = exp(1)))\r\n}\r\n\r\n# invert makeLog \r\nmakeUnLog = function (logVal, add, mul, base = exp(1))\r\n{\r\n  transVal = exp(logVal / mul)\r\n  val = transVal - add \r\n  return(val)\r\n}\r\n\r\n# verify if \"perSeason\" is good for \"frequency\" parameter\r\nfreqSeason = function(seasons,perSeason)\r\n{\r\n  if((seasons > 5 && perSeason > 3) || (seasons > 2 && perSeason > 7))\r\n    return (perSeason)\r\n  \r\n  return(1)\r\n}\r\n\r\n# find frequency using the dates, targetS is a \"recommended\" seasonality \r\nfindFreqFromDates = function(dates, targetS = \"autodetect from date\")\r\n{\r\n  freq = 1\r\n  N = length(dates)\r\n  nnn = c(\"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\")\r\n  seasons = rep(NaN,6)\r\n  names(seasons) = nnn\r\n  perSeason = seasons\r\n  \r\n  seasons[\"day\"] = round(as.numeric(difftime(dates[length(dates)], dates[1]), units=\"days\"))\r\n  seasons[\"hour\"] = round(as.numeric(difftime(dates[length(dates)], dates[1]), units=\"hours\"))\r\n  seasons[\"week\"] = round(as.numeric(difftime(dates[length(dates)], dates[1]), units=\"weeks\"))\r\n  seasons[\"month\"] = seasons[\"day\"] / 30\r\n  seasons[\"year\"] = seasons[\"day\"] / 365.25\r\n  seasons[\"quarter\"] = seasons[\"year\"] * 4\r\n  \r\n  perSeason = N/seasons\r\n  \r\n  if(targetS != \"autodetect from date\" && targetS != \"autodetect from date\") # target \r\n    freq = perSeason[targetS]\r\n  \r\n  if(freq < 2) # if TRUE, target season factor is not good \r\n    freq = 1\r\n  \r\n  for( s in rev(nnn)) # check year --> quarter --> etc\r\n    if(freq == 1 )\r\n      freq = freqSeason(seasons[s],perSeason[s])\r\n  \r\n  return(round(freq))\r\n}\r\n\r\n#decompose into 3 components, known frequency \r\nflexTSdecomposition = function(Time, vals, freq, trendSmoothness, myts, robustToOutliers, degree)\r\n{\r\n  SMOO_FACTOR = 1.43 # found experimentally do provide aesthetically pleasing results\r\n  \r\n  N = length(Time)\r\n  twin = getSTwindows(N, trendSmoothness= trendSmoothness, freq = freq)\r\n  \r\n  if(freq == 1)\r\n  {\r\n    s = (SMOO_FACTOR * trendSmoothness )\r\n    span = max(s, 0.2) # get from t smoothness\r\n    fit <- loess(vals ~ seq(1, length(Time)), degree = 1 + degree, span = span)\r\n    fit$time.series.df = data.frame(seasonal = rep(0, length(Time)), trend = fit$fitted, residuals = fit$residuals, data = vals)\r\n    \r\n  } \r\n  if(freq >1)\r\n  {\r\n    ## Convert to time series\r\n    fit <- stl(myts,  robust = robustToOutliers, s.degree = degree, t.degree = degree, s.window = \"periodic\", t.window = twin)\r\n    fit$time.series.df = as.data.frame(fit$time.series)\r\n    fit$fitted = fit$time.series.df$seasonal + fit$time.series.df$trend\r\n    fit$residuals = vals - fit$fitted\r\n    \r\n  }\r\n   \r\n  clean = fit$time.series.df[,1] + fit$time.series.df[,2]\r\n  seasonal = fit$time.series.df[,1] + mean(fit$time.series.df[,2])\r\n  remainder = fit$time.series.df[,3] + mean(vals)\r\n  trend = fit$time.series.df[,2]\r\n  dfTSD = data.frame(clean = clean, seasonal = seasonal, trend = trend, remainder = remainder)\r\n  return(list(fit = fit, dfTSD = dfTSD))\r\n  \r\n}\r\n\r\n#find relative part of signal\r\nexplained = function(sigModeled, sig)\r\n{\r\n  sig = sig - mean(sig)\r\n  sigModeled = sigModeled - mean(sigModeled)\r\n  normL2sig = norm(sig, type = \"2\")\r\n  normL2err = norm(sigModeled, type = \"2\")\r\n  return(( normL2err / ( normL2sig + 0.00001 )))\r\n}\r\n\r\n#next odd number\r\nnextodd = function(num)\r\n  return (round(num)+(round(num) %% 2 == 0))\r\n\r\n#get smoothness parameters for STL function\r\ngetSTwindows = function(numSamples, trendSmoothness= 0.5, freq = 4)\r\n{\r\n  getByPos = function(arr, frac)\r\n    arr[max(1,round(length(arr) * frac))]\r\n  \r\n  t = nextodd(freq*1.5)# default\r\n  allTS = seq(3, max(7, max(t*2, nextodd(numSamples/2))), by = 2)\r\n  return(getByPos(allTS,trendSmoothness))\r\n}\r\n\r\n#get valid frequency parameter, based on input from user \r\ngetFrequency = function(parsed_dates, values, tS, f)\r\n{\r\n  myFreq = f\r\n  grp = c(\"autodetect from value\",\"none\",\"manual\")\r\n  \r\n  if(!(tS %in% c(\"autodetect from value\",\"none\",\"manual\"))) #detect from date\r\n  {  \r\n    myFreq = findFreqFromDates(parsed_dates, targetS = tS)\r\n  }else{\r\n    if(tS == \"none\")\r\n    { myFreq = 1}\r\n    else\r\n    {\r\n      if(tS == \"autodetect from value\")\r\n        myFreq = freqFromValue(values)\r\n    }\r\n  }\r\n  numPeriods = floor(length(values)/myFreq)\r\n  if(numPeriods< 2)\r\n    myFreq = findFreqFromDates(parsed_dates, targetS = \"autodetect from date\")\r\n  return(myFreq)\r\n}\r\n\r\n#********* PBI Parameters Block ***************\r\n\r\nif(!exists(\"Time\"))\r\n\tTime = NULL \r\n\r\nif(!exists(\"Value\"))\r\n\tValue = NULL \r\n\r\nshowWarnInfo = TRUE  #default\r\nif (exists(\"settings_extra_params_show\")) \r\n{\r\n\tshowWarnInfo = settings_extra_params_show\r\n}\r\n\r\nif(exists(\"settings_model_params_show\") && settings_model_params_show == FALSE)\r\n\trm(list= ls(pattern = \"settings_model_params_\" ))\r\n\r\nif(exists(\"settings_algo_params_show\") && settings_algo_params_show == FALSE)\r\n\trm(list= ls(pattern = \"settings_algo_params_\" ))\r\n\r\nif(exists(\"settings_plot_params_show\") && settings_plot_params_show == FALSE)\r\n\trm(list= ls(pattern = \"settings_plot_params_\" ))\r\n\r\nif(exists(\"settings_extra_params_show\") && settings_extra_params_show == FALSE)\r\n\trm(list= ls(pattern = \"settings_extra_params_\" ))\r\n\r\n##PBI_PARAM: display_name: Decomposition model, tooltip:Switch between additive and multiplicative decomposition models \r\n# Type: enumeration, default:'automatic', \r\n# Min: , Max:\r\n# enumeration options: additive ,multiplicative ,automatic ,\r\nmodelType = 'automatic'  #default\r\nif (exists(\"settings_model_params_modelType\")) \r\n{\r\n\tmodelType = settings_model_params_modelType\r\n}\r\n\r\n##PBI_PARAM: display_name: Seasonal factor, tooltip:Specify recommended seasonal factor\r\n# Type: enumeration, default:'autodetect from date', \r\n# Min: , Max:\r\n# enumeration options: autodetect from date ,none ,manual ,hour ,day ,week ,month ,quarter ,year ,\r\ntargetSeasonality = 'autodetect from date'  #default\r\nif (exists(\"settings_model_params_targetSeasonality\")) \r\n{\r\n\ttargetSeasonality = settings_model_params_targetSeasonality\r\n}\r\n\r\n##PBI_PARAM: display_name: Frequency, tooltip:Number of samples per season\r\n# Type: numeric, default:12, \r\n# Min: 1, Max:10000\r\nfreq = 12  #default\r\nif (exists(\"settings_model_params_freq\")) \r\n{\r\n\tfreq = settings_model_params_freq\r\n\tfreq = max( min (freq, 10000), 1)\r\n}\r\n\r\n##PBI_PARAM: display_name: Degree, tooltip:Degree of locally-fitted polynomial in seasonal extraction and trend extraction\r\n# Type: bool, default:FALSE, \r\n# Min: , Max:\r\ndegree = FALSE  #default\r\nif (exists(\"settings_algo_params_degree\")) \r\n{\r\n\tdegree = settings_algo_params_degree\r\n}\r\n\r\n##PBI_PARAM: display_name: Robust to outliers, tooltip:Indicating if robust fitting be used in the loess procedure\r\n# Type: bool, default:TRUE, \r\n# Min: , Max:\r\nrobustToOutliers = TRUE  #default\r\nif (exists(\"settings_algo_params_robustToOutliers\")) \r\n{\r\n\trobustToOutliers = settings_algo_params_robustToOutliers\r\n}\r\n\r\n##PBI_PARAM: display_name: Trend smoothness, tooltip:Trend smoothness\r\n# Type: numeric, default:50, \r\n# Min: 1, Max:100\r\ntrendSmoothness = 50  #default\r\nif (exists(\"settings_algo_params_percentile\")) \r\n{\r\n\ttrendSmoothness = settings_algo_params_percentile\r\n\ttrendSmoothness = max( min (trendSmoothness, 100), 1)\r\n}\r\n\r\n##PBI_PARAM: display_name: Plot type, tooltip:specify the plot type\r\n# Type: enumeration, default:'all', \r\n# Min: , Max:\r\n# enumeration options: all ,trend ,seasonal ,clean ,remainder ,byseason ,byseasonClean ,\r\nplotType = 'all'  #default\r\nif (exists(\"settings_plot_params_plotType\")) \r\n{\r\n\tplotType = settings_plot_params_plotType\r\n}\r\n\r\n##PBI_PARAM: display_name: Line width, tooltip:line width\r\n# Type: numeric, default:10, \r\n# Min: 1, Max:50\r\nlineWidth = 10  #default\r\nif (exists(\"settings_plot_params_weight\")) \r\n{\r\n\tlineWidth = settings_plot_params_weight\r\n\tlineWidth = max( min (lineWidth, 50), 1)\r\n}\r\n\r\n##PBI_PARAM: display_name: Line color, tooltip:line color\r\n# Type: fill, default:'red', \r\n# Min: , Max:\r\nlineCol = 'red'  #default\r\nif (exists(\"settings_plot_params_lineCol\")) \r\n{\r\n\tlineCol = settings_plot_params_lineCol\r\n}\r\n\r\n##PBI_PARAM: display_name: Labels color, tooltip:labels color\r\n# Type: fill, default:'orange', \r\n# Min: , Max:\r\nlabelsCol = 'orange'  #default\r\nif (exists(\"settings_plot_params_labelsCol\")) \r\n{\r\n\tlabelsCol = settings_plot_params_labelsCol\r\n}\r\n\r\n##PBI_PARAM: display_name: Labels font size, tooltip:labels font size\r\n# Type: numeric, default:10, \r\n# Min: 8, Max:40\r\nlabelsFont = 10  #default\r\nif (exists(\"settings_plot_params_textSize\")) \r\n{\r\n\tlabelsFont = settings_plot_params_textSize\r\n\tlabelsFont = max( min (labelsFont, 40), 8)\r\n}\r\n\r\n##PBI_PARAM: display_name: Font size, tooltip:\r\n# Type: numeric, default:8, \r\n# Min: 8, Max:40\r\ninfoFontSize = 10  #default\r\nif (exists(\"settings_extra_params_textSize\")) \r\n{\r\n\tinfoFontSize = settings_extra_params_textSize\r\n\tinfoFontSize = max( min (infoFontSize, 40), 10)\r\n}\r\n\r\n##PBI_PARAM: display_name: Text color, tooltip:Text color\r\n# Type: fill, default:'brown', \r\n# Min: , Max:\r\ninfoCol = 'brown'  #default\r\nif (exists(\"settings_extra_params_infoCol\")) \r\n{\r\n\tinfoCol = settings_extra_params_infoCol\r\n}\r\n \r\n \r\n{\r\n  \r\n  #update params to correct scale\r\n  trendSmoothness = trendSmoothness / 100 # from % to [0,1]\r\n  labelsFont = labelsFont / 10 # convert from range 8-40\r\n  lineWidth = lineWidth / 8 # convert from 1-50 \r\n  infoFontSize = infoFontSize / 10\r\n\r\n  pbiInfo = \"\" # warning or info string \r\n  \r\n  #check if all Roles exist\r\n  if(!(exists(\"Value\") && exists(\"Time\")))\r\n  {\r\n    Value = NULL; Time = ts(); plotType = \"empty\"\r\n  }\r\n  else\r\n  {\r\n    nameTime = names(Time)[1]\r\n    Time = as.character(Time[,1]);  names(Time)[1] = nameTime \r\n    N = length(Time)\r\n    if(N < minSamples2run)\r\n    {\r\n      Value = NULL; Time = ts(); plotType = \"empty\"\r\n      pbiInfo = cutStr2Show(\"Warning: Not enough samples for analysis\", strCex = 1.2, partAvailable = 0.95)\r\n      \r\n    }\r\n  }\r\n  if(plotType != \"empty\")\r\n  {\r\n    parsed_dates=strptime(Time, \"%Y-%m-%dT%H:%M:%S\", tz = \"UTC\")\r\n    if((any(is.na(parsed_dates))))\r\n    {\r\n      Value = NULL; Time = ts(); plotType = \"empty\"\r\n      pbiInfo = cutStr2Show(\"Warning: Only 'Date', 'Time', 'Date/Time' types are allowed for Time\", strCex = 1.2, partAvailable = 0.95)\r\n    }\r\n    else\r\n      if(!is.numeric(Value[,1]))\r\n      {\r\n        Value = NULL; Time = ts(); plotType = \"empty\"\r\n        pbiInfo = cutStr2Show(\"Warning: Only numeric types are allowed for Value\", strCex = 1.2, partAvailable = 0.95)\r\n      }\r\n      else\r\n        if(length(unique(Value[,1])) < minUniqueValues)\r\n        {\r\n          Value = NULL; Time = ts(); plotType = \"empty\"\r\n          pbiInfo = cutStr2Show(\"Warning: No sufficient variance in Value\", strCex = 1.2, partAvailable = 0.95)\r\n        }\r\n  } \r\n  \r\n  if(plotType != \"empty\")\r\n  {\r\n    interval = difftime(parsed_dates[length(parsed_dates)],parsed_dates[1])/(length(parsed_dates)-1) # force equal spacing \r\n    \r\n    vals = avals = Value[,1]\r\n    mvals = NULL\r\n    \r\n    if(modelType != \"additive\")\r\n    {\r\n      mvals = makeLog(vals)\r\n      vals = mvals$logVal\r\n    }\r\n    \r\n    #detect the frequency \r\n    freqv = getFrequency(parsed_dates, vals, targetSeasonality, freq)\r\n    \r\n    # Convert to time series\r\n    mytsAdd = myts <- ts(vals, start = as.Date(min(Time)), frequency = freqv)\r\n    \r\n    if(!is.null(mvals))\r\n    {\r\n      afreq = getFrequency(parsed_dates,avals,targetSeasonality,freq)\r\n      mytsAdd <- ts(avals, start = as.Date(min(Time)), frequency = afreq)\r\n    }\r\n    \r\n    # decompose (additive or multiplicative with or without seasonality)\r\n    flexTSres <- flexTSdecomposition(Time, vals, freqv, trendSmoothness, myts, robustToOutliers, degree)\r\n    \r\n    dfTSD = flexTSres$dfTSD\r\n    \r\n    #explained variance\r\n     if(is.null(mvals))\r\n        evars = apply(dfTSD[,-1],2,FUN = explained, sig = vals)\r\n    else\r\n       evars = apply(makeUnLog(dfTSD[,-1],mvals$add, mvals$mul), 2, FUN = explained, sig = avals)\r\n       \r\n    \r\n    evars = round(100 * evars / sum(evars))\r\n    \r\n    if(modelType == \"automatic\")\r\n    {#compute the same for additive model, compare and select one \r\n      flexTSresAdd <- flexTSdecomposition(Time, avals, afreq, trendSmoothness, mytsAdd, robustToOutliers, degree)\r\n      dfTSDadd <- flexTSresAdd$dfTSD\r\n      evarsAdd = apply(dfTSDadd[,-1], 2, FUN = explained, sig = avals)\r\n      evarsAdd = round(100*evarsAdd/sum(evarsAdd))\r\n      \r\n      if(evarsAdd[3]<evars[3]) # do additive\r\n      {\r\n        modelType = \"additive\"\r\n        myts = mytsAdd\r\n        mvals = NULL\r\n        freqv = afreq\r\n        dfTSD = dfTSDadd\r\n        evars = evarsAdd\r\n        flexTSres = flexTSresAdd\r\n        vals = avals\r\n      }\r\n      else  # do multiplicative\r\n        modelType = \"multiplicative\" \r\n    }\r\n    \r\n    #plots \r\n    if (plotType %in% c(\"byseason\",\"byseasonClean\") && freqv == 1)\r\n      plotType = \"clean\"\r\n    \r\n    if(showWarnInfo)\r\n      pbiInfo = CreateInfo(modelType, freqv, evars, plotType)\r\n  }\r\n  pbiInfo = cutStr2Show(pbiInfo, strCex = infoFontSize )\r\n  \r\n  ## Plot the result\r\n  if(plotType == \"all\" )\r\n  {\r\n    if(is.null(mvals))\r\n      mts0 = data.frame(data=vals, seasonal = dfTSD$seasonal  , trend=dfTSD$trend, remainder = vals- dfTSD$clean)\r\n    else\r\n    {\r\n      mts0 = data.frame(data=avals, seasonal =  makeUnLog(dfTSD$seasonal, mvals$add, mvals$mul)  , \r\n                   trend=makeUnLog(dfTSD$trend,mvals$add, mvals$mul))\r\n      mts0$remainder = mts0$data - makeUnLog(dfTSD$clean,mvals$add, mvals$mul)\r\n    }\r\n   \r\n    \r\n    names(mts0) = sapply(names(mts0),cutStr2Show, strCex = labelsFont , isH = F, partAvailable = 0.24, maxChar = 1)\r\n    print(names(mts0))\r\n    \r\n    mts1 = ts(mts0, start = as.Date(min(Time)), frequency= freqv)\r\n    \r\n    mts1_zoo = as.zoo(mts1)\r\n    time(mts1_zoo) = parsed_dates\r\n    \r\n    \r\n    p <- proto(plot.zoo = plot.zoo, mtext = function(...) \r\n      graphics::mtext(..., cex = labelsFont, col = labelsCol))\r\n    \r\n    with(p, plot.zoo)(mts1_zoo, main=\"\", col = lineCol, plot.type = c(\"multiple\"),\r\n                      yax.flip = TRUE,\r\n                      col.lab = labelsCol,  lwd =lineWidth,  cex.lab = labelsFont)\r\n    \r\n    title(main=\"\", sub = pbiInfo, cex.sub = infoFontSize, col.sub = infoCol)\r\n  }\r\n  else\r\n    if((plotType %in% c(\"clean\",\"trend\", \"remainder\", \"seasonal\"))) # clean, trend, remainder\r\n    {\r\n      myts_zoo = as.zoo(mytsAdd)# changed to zoo type because it allows to replace dates\r\n      time(myts_zoo) = parsed_dates\r\n      \r\n      # plot input data\r\n      plot(myts_zoo, col=\"gray\", \r\n           main=\"\",\r\n           lwd = lineWidth/2,  col.lab = labelsCol, cex.lab = labelsFont, xlab = \"\", ylab = \"\")\r\n      \r\n      \r\n      if(!is.null(mvals))\r\n      {\r\n        dfTSD[,plotType] = makeUnLog(dfTSD[,plotType], mvals$add, mvals$mul)\r\n        if(plotType==\"remainder\")\r\n          dfTSD$clean = makeUnLog(dfTSD$clean, mvals$add, mvals$mul)\r\n      }\r\n      m = 0; meanAvals = mean(avals)\r\n      \r\n      dfTSD$remainder = avals - dfTSD$clean + meanAvals\r\n      \r\n      dfTSD <- ts(dfTSD, start = as.Date(min(Time)), frequency= freqv)\r\n      \r\n     \r\n      \r\n      if(plotType %in% c(\"seasonal\")) # draw around mean\r\n          m = - mean(dfTSD[,plotType]) + meanAvals\r\n      \r\n      line_zoo = as.zoo(dfTSD[,plotType] + m)\r\n      time(line_zoo) = parsed_dates\r\n      \r\n      lines(line_zoo, col = lineCol, lwd = lineWidth)\r\n      \r\n      abline(a = meanAvals, b = 0, col = \"green\", lty = 2, col.lab = labelsCol)\r\n      \r\n      xlab=names(Time)[1]; ylab=names(Value)[1] \r\n      ylab = cutStr2Show(ylab,labelsFont, isH = FALSE, maxChar = 1)\r\n      xlab = cutStr2Show(xlab,labelsFont, isH = TRUE, maxChar = 1)\r\n      title(main=\"\", \r\n            xlab = xlab, ylab = ylab,\r\n            col.lab=labelsCol, cex.lab=labelsFont, sub = pbiInfo, cex.sub = infoFontSize, col.sub = infoCol)\r\n      \r\n    } else \r\n      if(plotType %in% c(\"byseason\",\"byseasonClean\"))\r\n      {\r\n        fit <- flexTSres$fit\r\n        par(lwd = lineWidth, col = lineCol)\r\n        d = fit$time.series[,\"trend\"] + fit$time.series[,\"seasonal\"]\r\n        ylab =paste(\"Clean\", names(Value)[1], sep=\" \")\r\n        \r\n        if(plotType == \"byseason\")\r\n        {\r\n          d = d + fit$time.series[,\"remainder\"]\r\n          ylab =names(Value)[1]\r\n        }\r\n        if(!is.null(mvals))\r\n          ylab =paste(\"log(\", ylab, \")\", sep=\"\")\r\n        xlab = \"Season\"\r\n        \r\n        ylab = cutStr2Show(ylab,labelsFont, isH = FALSE, maxChar = 1)\r\n        xlab = cutStr2Show(xlab,labelsFont, isH = TRUE, maxChar = 1)\r\n        \r\n        monthplot(d , main=\"\", ylab = ylab, xlab = xlab,  \r\n                  col.lab=labelsCol, cex.lab=labelsFont, col.base = \"gray\", lwd.base = lineWidth/2, bty='n')\r\n        box(col = 'black', lwd =1)\r\n      }\r\n  else #empty\r\n  {\r\n    plot.new()\r\n    title(main=\"\", sub = pbiInfo, cex.sub = 1.2, col.sub = infoCol)\r\n  }\r\n  \r\n}"}}}],"objects":{"settings_model_params":{"displayName":"Time series model","description":"Adjust the type of decomposition and the seasonality","properties":{"modelType":{"displayName":"Decomposition model","description":"Switch between additive and multiplicative decomposition models ","type":{"enumeration":[{"displayName":"additive","value":"additive"},{"displayName":"multiplicative","value":"multiplicative"},{"displayName":"automatic","value":"automatic"}]}},"targetSeasonality":{"displayName":"Seasonal factor","description":"Specify recommended seasonal factor","type":{"enumeration":[{"displayName":"autodetect from date","value":"autodetect from date"},{"displayName":"none","value":"none"},{"displayName":"manual","value":"manual"},{"displayName":"hour","value":"hour"},{"displayName":"day","value":"day"},{"displayName":"week","value":"week"},{"displayName":"month","value":"month"},{"displayName":"quarter","value":"quarter"},{"displayName":"year","value":"year"}]}},"freq":{"displayName":"Frequency","description":"Number of samples per season","type":{"numeric":true}}}},"settings_algo_params":{"displayName":"Algorithm parameters","description":"Modify parameters for 'Seasonal Decomposition of Time Series using Loess'","properties":{"degree":{"displayName":"Degree","description":"Degree of locally-fitted polynomial in seasonal extraction and trend extraction","type":{"bool":true}},"robustToOutliers":{"displayName":"Robust to outliers","description":"Indicates whether robust fitting will be used in the Loess procedure","type":{"bool":true}},"percentile":{"displayName":"Trend smoothness","description":"Trend smoothness","type":{"numeric":true}}}},"settings_plot_params":{"displayName":"Graphical parameters","description":"Select the plot type and visualisation attributes","properties":{"plotType":{"displayName":"Plot type","description":"specify the plot type","type":{"enumeration":[{"displayName":"decomposition","value":"all"},{"displayName":"trend","value":"trend"},{"displayName":"seasonal","value":"seasonal"},{"displayName":"clean","value":"clean"},{"displayName":"remainder","value":"remainder"},{"displayName":"by season","value":"byseason"},{"displayName":"by season clean","value":"byseasonClean"}]}},"weight":{"displayName":"Line width","description":"line width","type":{"numeric":true}},"lineCol":{"displayName":"Line color","description":"line color","type":{"fill":{"solid":{"color":true}}}},"labelsCol":{"displayName":"Labels color","description":"labels color","type":{"fill":{"solid":{"color":true}}}},"textSize":{"displayName":"Labels font size","description":"labels font size","type":{"numeric":true}}}},"settings_extra_params":{"displayName":"Show information","description":" Show infromation and warnings","properties":{"show":{"type":{"bool":true}},"textSize":{"displayName":"Font size","type":{"numeric":true}},"infoCol":{"displayName":"Text color","description":"Text color","type":{"fill":{"solid":{"color":true}}}}}},"rcv_script":{"properties":{"provider":{"type":{"text":true}},"source":{"type":{"scripting":{"source":true}}}}}},"suppressDefaultTitle":true},"dependencies":{"cranPackages":[{"name":"proto","displayName":"proto: Prototype Object-Based Programming","url":"https://cran.r-project.org/web/packages/proto/index.html"},{"name":"zoo","displayName":"zoo: S3 Infrastructure for Regular and Irregular Time Series","url":"https://cran.r-project.org/web/packages/zoo/index.html"}]},"stringResources":{},"content":{"js":"var powerbi;!function(t){!function(t){!function(t){!function(t){function e(t,e,a,i){if(t){var s=t[e];if(s){var r=s[a];if(void 0!==r)return r}}return i}function a(t,e,a,i,s,r){if(t){var n=t[e];if(n){var o=n[a];if(o<s)return s;if(o>r)return r;if(void 0!==o)return o}}return i}function i(t,e,a,i,s,r){if(t){var n=t[e];if(n){var o=n[a];if(void 0!==o)return o>r?r:o<s?s:o}}return i}function s(t,e,a,i,s,r){return r&&e==a&&1==s?i:r&&e!=a&&0==s?i:t}function r(t,e){return\"auto\"!=e?\"None\":\"auto\"==e&&\"None\"==t?\"fast\":t}function n(t,e,a){return t<e?e:t>a?a:t}function o(t,e,a,i,s){var r=t.objects;if(r){var n=r[e];if(n){var o=n[a];if(o){var l=o[i];if(void 0!==l)return l}}}return s}function l(t,e,a,i){if(t){var s=t[e];if(s){var r=s[a];if(void 0!==r&&void 0!==r.solid&&void 0!==r.solid.color)return r.solid.color}}return i}t.getValue=e,t.getValueMinMax=a,t.getValueNumberMinMax=i,t.ifStringReturnString=s,t.ifStringReturnStringClustersMethod=r,t.inMinMax=n,t.getCategoricalObjectValue=o,t.getFillValue=l}(t.PBI_CV_CAD60C71_FAD5_4B59_A498_A7FB0DDC7A2B||(t.PBI_CV_CAD60C71_FAD5_4B59_A498_A7FB0DDC7A2B={}))}(t.visual||(t.visual={}))}(t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){!function(t){!function(t){!function(t){var e=function(){function e(t){this.imageDiv=document.createElement(\"div\"),this.imageDiv.className=\"rcv_autoScaleImageContainer\",t.element.appendChild(this.imageDiv),this.imageElement=document.createElement(\"img\"),this.imageElement.className=\"rcv_autoScaleImage\",this.imageDiv.appendChild(this.imageElement),this.settings_model_params={modelType:\"automatic\",targetSeasonality:\"autodetect from date\",freq:12},this.settings_algo_params={degree:!1,robustToOutliers:!0,percentile:50},this.settings_plot_params={plotType:\"all\",weight:10,lineCol:\"red\",labelsCol:\"orange\",textSize:10},this.settings_extra_params={show:!0,textSize:10,infoCol:\"brown\"}}return e.prototype.update=function(e){var a=e.dataViews;if(a&&0!==a.length&&null!=a){var i=a[0];if(null!=i&&i&&i.metadata){this.settings_model_params={modelType:t.getValue(i.metadata.objects,\"settings_model_params\",\"modelType\",\"automatic\"),targetSeasonality:t.getValue(i.metadata.objects,\"settings_model_params\",\"targetSeasonality\",\"autodetect from date\"),freq:t.getValue(i.metadata.objects,\"settings_model_params\",\"freq\",12)},this.settings_algo_params={degree:t.getValue(i.metadata.objects,\"settings_algo_params\",\"degree\",!1),robustToOutliers:t.getValue(i.metadata.objects,\"settings_algo_params\",\"robustToOutliers\",!0),percentile:t.getValue(i.metadata.objects,\"settings_algo_params\",\"percentile\",50)},this.settings_plot_params={plotType:t.getValue(i.metadata.objects,\"settings_plot_params\",\"plotType\",\"all\"),weight:t.getValue(i.metadata.objects,\"settings_plot_params\",\"weight\",10),lineCol:t.getValue(i.metadata.objects,\"settings_plot_params\",\"lineCol\",\"red\"),labelsCol:t.getValue(i.metadata.objects,\"settings_plot_params\",\"labelsCol\",\"orange\"),textSize:t.getValue(i.metadata.objects,\"settings_plot_params\",\"textSize\",10)},this.settings_extra_params={show:t.getValue(i.metadata.objects,\"settings_extra_params\",\"show\",!0),textSize:t.getValue(i.metadata.objects,\"settings_extra_params\",\"textSize\",10),infoCol:t.getValue(i.metadata.objects,\"settings_extra_params\",\"infoCol\",\"brown\")};var s=null;i.scriptResult&&i.scriptResult.payloadBase64&&(s=\"data:image/png;base64,\"+i.scriptResult.payloadBase64),this.imageElement.src=s?s:null,this.onResizing(e.viewport)}}},e.prototype.onResizing=function(t){this.imageDiv.style.height=t.height+\"px\",this.imageDiv.style.width=t.width+\"px\"},e.prototype.enumerateObjectInstances=function(e){var a=e.objectName,i=[];switch(a){case\"settings_model_params\":i.push({objectName:a,properties:{modelType:this.settings_model_params.modelType,targetSeasonality:this.settings_model_params.targetSeasonality},selector:null}),\"manual\"==this.settings_model_params.targetSeasonality&&i.push({objectName:a,properties:{freq:t.inMinMax(this.settings_model_params.freq,1,1e4)},selector:null});break;case\"settings_algo_params\":i.push({objectName:a,properties:{degree:this.settings_algo_params.degree,robustToOutliers:this.settings_algo_params.robustToOutliers,percentile:t.inMinMax(this.settings_algo_params.percentile,1,100)},selector:null});break;case\"settings_plot_params\":i.push({objectName:a,properties:{plotType:this.settings_plot_params.plotType,weight:t.inMinMax(this.settings_plot_params.weight,1,50),lineCol:this.settings_plot_params.lineCol,labelsCol:this.settings_plot_params.labelsCol,textSize:t.inMinMax(this.settings_plot_params.textSize,8,40)},selector:null});break;case\"settings_extra_params\":i.push({objectName:a,properties:{show:this.settings_extra_params.show,textSize:t.inMinMax(this.settings_extra_params.textSize,8,40),infoCol:this.settings_extra_params.infoCol},selector:null})}return i},e}();t.Visual=e}(t.PBI_CV_CAD60C71_FAD5_4B59_A498_A7FB0DDC7A2B||(t.PBI_CV_CAD60C71_FAD5_4B59_A498_A7FB0DDC7A2B={}))}(t.visual||(t.visual={}))}(t.extensibility||(t.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(t){!function(e){!function(e){e.PBI_CV_CAD60C71_FAD5_4B59_A498_A7FB0DDC7A2B={name:\"PBI_CV_CAD60C71_FAD5_4B59_A498_A7FB0DDC7A2B\",displayName:\"Time series decomposition\",class:\"Visual\",version:\"1.0.1\",apiVersion:\"1.3.0\",create:function(e){return new t.extensibility.visual.PBI_CV_CAD60C71_FAD5_4B59_A498_A7FB0DDC7A2B.Visual(e)},custom:!0}}(e.plugins||(e.plugins={}))}(t.visuals||(t.visuals={}))}(powerbi||(powerbi={}));","css":".visual-PBI_CV_CAD60C71_FAD5_4B59_A498_A7FB0DDC7A2B .rcv_autoScaleImageContainer{position:relative}.visual-PBI_CV_CAD60C71_FAD5_4B59_A498_A7FB0DDC7A2B .rcv_autoScaleImageContainer .rcv_autoScaleImage{max-width:100%;max-height:100%;position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%);-webkit-transform:translateY(-50%) translateX(-50%)}","iconBase64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAVBJREFUeNpiYKAF6J04xQGEqWEWE5R2gGKKAQulBni37FKAOsYfiBNZKDDAHkoLAPEBID5IlAuBBgggGRAAxApQAzYC8cStNW4XCHoZaEgAkgsMkFyQCDTgAFFh+OoPrz3QoP1QQy5ADWkEGrCBkkiZCMSBQEM+4NLwJNEaFAQMMvOPfsBroBjL54Nba+I34NMEFQf5AiTuiC8dooP1II0wg5EAzDABoFwDskVAHIA1UqAKYQbNBwUBVHw+VCwQGtMgCw9ALQA5AOS7DSxohoEiJB/qnQdQTTCDQLHtCA2GC0DxQqhBINAIFJ+A4mXBb+/koQoKgZIXoBodoQYhG8YADd8FQAqEA2GGIRcODTsrM/4Dbe3HFqtYwpJwsvnKxgVyVSG6AlzJg1Bpw3BfSGkjNYsvqgHkWK4HhmU9JYYV5+cwwgwExxhQ4AGlLgQIMABpuYLve7oVDwAAAABJRU5ErkJggg=="}}